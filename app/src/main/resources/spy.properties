# spy.properties

# 模块列表
modulelist=com.p6spy.engine.spy.P6SpyFactory,com.p6spy.engine.logging.P6LogFactory,com.p6spy.engine.outage.P6OutageFactory

# 真实的 JDBC Driver
driverlist=org.postgresql.Driver

# 关键配置：指定自定义的格式化策略类
logMessageFormat=com.minjor.data.config.P6spyFormatter

# 配置 appender 为 FileLogger 或 MemoryBasedPrintWriter 等，
# 因为我们不再使用 Slf4JLogger 来打印，而是由我们的 CustomP6spyFormatter 完成打印
# StdoutLogger 也可以，但通常我们会配合 MessageFormattingStrategy 使用一个不直接打印的 appender
# 或者使用一个只是简单写入的 appender，让 format 方法来处理真正的日志记录
# 对于自定义 formatter，最常用的是 FileLogger 或 MemoryBasedPrintWriter，但 FileLogger 会写入文件。
# 如果我们只想控制台输出或通过 SLF4J 输出，可以使用 MemoryBasedPrintWriter 并配合自定义逻辑，
# 但最简单的方式是直接在 format 方法里处理，appender 用一个“哑”的，如 FileLogger 但重定向到 /dev/null
# 实际上，如果 format 返回 null，很多 appender 不会输出任何东西，这正是我们想要的。
# 所以这里可以使用 FileLogger 或其他，但关键是 format 方法的返回值。
# 为了最清晰地表明意图，我们仍然使用 FileLogger，但重点是 format 方法。
appender=com.p6spy.engine.spy.appender.FileLogger
# 如果 format 方法返回 null，这个 appender 就不会写入任何内容到文件。
# 你也可以尝试 MemoryBasedPrintWriter
# appender=com.p6spy.engine.spy.appender.MemoryBasedPrintWriter

# 日志文件名 (因为使用了 FileLogger)
logfile=spy.log

# 日期格式
dateformat=yyyy-MM-dd HH:mm:ss.SSS

# 可选：是否开启过滤
filter=false

# 可选：执行时间阈值 (毫秒)，只有超过此时间才记录
executionThreshold=0

# 可选：排除类别
excludecategories=info,debug,result,resultset